# Прокси / Заместитель / Суррогат proxy
### Краткое описание
Это шаблон, предоставляющий объект, который контролирует доступ к другому объекту,
перехватывая все вызовы (выполняет функцию контейнера).
### Классическое определение и применение
Применяется, когда
- Необходимо контролировать доступ к объекту, не изменяя при этом поведение клиента. 
- Необходимо иметь доступ к объекту так, чтобы не создавать реальные объекты непосредственно, а через другой объект, который может иметь дополнительную функциональность
Как этого добиться:

Создать суррогат реального объекта. «Заместитель» хранит ссылку, которая позволяет
заместителю обратиться к реальному субъекту (объект класса «Заместитель» может обращаться
к объекту класса «Субъект», если интерфейсы «Реального Субъекта» и «Субъекта» одинаковы).
Поскольку интерфейс «Реального Субъекта» идентичен интерфейсу «Субъекта», так, что «Заместителя»
можно подставить вместо «Реального Субъекта», контролирует доступ к «Реальному Субъекту»,
может отвечать за создание или удаление «Реального Субъекта». «Субъект» определяет общий
для «Реального Субъекта» и «Заместителя» интерфейс так, что «Заместитель» может быть использован везде,
где ожидается «Реальный Субъект». При необходимости запросы могут быть переадресованы «Заместителем»
«Реальному Субъекту».

![](https://habrastorage.org/r/w1560/getpro/habr/post_images/3c3/c0f/87d/3c3c0f87d7e200b0b383223e547c7f4e.jpg)
![](https://github.com/mperestoronin/JavaPatterns/blob/main/photos/proxy.png)

### Классы и интерфейсы паттерна
- интерфейс service - содержит единственный метод doIt (иногда называют request)
- RealService - класс, реализующий service
- ServiceProxy - дублирует RealService, а также содержит ссылку на RealService. Также реализует интерфейс service.
Служит своего рода заместителем realService.
- Client - тот, кто непостредсвенно отправляет запросы. Client не знает, работает ли он с ServiceProxy или с RealService
### Детальный разбор
По сути мы вместо предоставления клиенту доступа к оригинальному объекту, подсовываем ему его двойник с чуть расширенным
функционалом и ссылкой на оригинальный объект. Этот объект заместитель будет контролировать доступ к оригинальному объекту.
Тогда клиент, не подозревая этого, будет обращаться к заместителю (двойнику), а заместитель будет управлять доступом к 
оригинальному объекту и даже (иногда) его жизненным циклом. И при необходимости переадресовывать ему вызовы клиента.

### Виды паттерна:
- Протоколирующий прокси: сохраняет в лог все вызовы «Субъекта» с их параметрами.
-Удалённый заместитель (англ. remote proxies): обеспечивает связь с «Субъектом», который находится в другом адресном пространстве или на удалённой машине. Также может отвечать за кодирование запроса и его аргументов и отправку закодированного запроса реальному «Субъекту»,
- Виртуальный заместитель (англ. virtual proxies): обеспечивает создание реального «Субъекта» только тогда, когда он действительно понадобится. Также может кэшировать часть информации о реальном «Субъекте», чтобы отложить его создание,
- Копировать-при-записи: обеспечивает копирование «субъекта» при выполнении клиентом определённых действий (частный случай «виртуального прокси»).
- Защищающий заместитель (англ. protection proxies): может проверять, имеет ли вызывающий объект необходимые для выполнения запроса права.
- Кэширующий прокси: обеспечивает временное хранение результатов расчёта до отдачи их множественным клиентам, которые могут разделить эти результаты.
- Экранирующий прокси: защищает «Субъект» от опасных клиентов (или наоборот).
- Синхронизирующий прокси: производит синхронизированный контроль доступа к «Субъекту» в асинхронной многопоточной среде.
- «Умная» ссылка (англ. smart reference proxy): производит дополнительные действия, когда на «Субъект» создается ссылка, например, рассчитывает количество активных ссылок на «Субъект».
### Применение
Шаблон Proxy может применяться в случаях работы с сетевым соединением, с огромным объектом в памяти (или на диске) или с любым другим ресурсом, который сложно или тяжело копировать. Хорошо известный пример применения — объект, подсчитывающий число ссылок.
### Ленивая инициализация
Рассмотрим задачу реализации игры «Сапер». Будем полагать, что для ячеек (Cell), которые бывают заминированными (Mine) и пустыми (Empty), существуют некоторые громоздкие графические изображения. Для заминированной ячейки — мина, для пустой ячейки изображение с количеством мин в соседних клетках. При этом, само изображение хранится в каждой ячейке и инстанциируется в момент ее создания. Игрок же, видит изображение ячейки только после ее открытия (операция open()). Поэтому, было бы разумным инстанциировать ячейки в тот момент, когда игрок пытается их открыть, чтобы сократить расходы общей памяти для хранения изображений. Однако, такой подход тут применить нельзя. Дело в том, что до операции open() у каждой ячейки вызываются операции getTop(), getLeft() для получения координат ячейки. Но если ячейка еще не будет создана, о каких ее координатах может идти речь?

Использование паттерна прокси решает данную проблему. Вместо оригинальных объектов клиент будет использовать их земестители (MineProxy, EmptyProxy). При этом становится возможной ленивая инициализация ячеек, ввиду того, что оригинальный объект создается лишь при вызове операции open() у прокси а на запросы о получении координат (getTop(), getLeft()) прокси отвечает самостоятельно, по крайней мере до момента создания оригинального объекта.
### Реализация
``` java
public abstract class Cell {
  public static final int OPENED = 0;
  public static final int CLOSED = 1;
  
  protected int status;

  protected int left, top;

  public Cell(int left, int top) {
    super();
    
    this.left = left;
    this.top = top;
    this.status = Cell.CLOSED;
  }
  
  /**
   * Открыть данную ячейку. Будем считать, что в этой операции происходит некоторая
   * ресурсоемкая операция. Например, загрузка изображения, для отображения содержимого ячейки.
   */
  public void open() {  
    this.status = Cell.OPENED;
  }

  public int getLeft() {
    return left;
  }
  
  public int getTop() {
    return top;
  }
  
  public int getStatus() {
    return status;
  }

  /**
   * Единственная абстрактная операция, возвращаяет количество очков за открытие данной ячейки.
   */
  public abstract int getPoints();  
}

/**
* Уточнение ячейки минного поля, в качестве пустой ячейки
*/
public class Empty extends Cell {
  
  public Empty(int left, int top) {
    super(left, top);
    
    // загружаем тяжелое изображение пустой ячейки.
  }

  @Override
  public int getPoints() {
    return 10;  // 10 очков за открытую пустую ячейку
  }
}

/**
* Уточнение ячейки, как ячейки с миной.
*/
public class Mine extends Cell {
  
  public Mine(int left, int top) {
    super(left, top);
    
    // загружаем тяжелое изображение ячейки c миной
  }

  @Override
  public int getPoints() {
    return 100;   // 100 очков за открытую мину
  }
}

/**
* Прокси для пустой ячейки
*/
public class EmptyProxy extends Cell {
  private Empty proxy; // ссылка на пустую ячейку

  public EmptyProxy(int left, int top) {
    super(left, top);
    this.proxy = null;
  }

  /**
   * Ленивая инициализация пустой ячейки
   */
  @Override
  public void open() {
    if (proxy == null) {
      proxy = new Empty(left, top);
    }
    
    proxy.open();
  }

  @Override
  public int getLeft() {
    if (proxy == null) {
      return left;
    } else {
      return proxy.getLeft();
    }
  
  }
  
  @Override
  public int getTop() {
    if (proxy == null) {
      return top;
    } else {
      return proxy.getTop();
    }
  }

  @Override
  public int getStatus() {
    if (proxy == null) {
      return status;
    } else {
      return proxy.getStatus();
    }
  }

  @Override
  public int getPoints() {
    if (proxy == null) {
      return 10;
    } else {
      return proxy.getPoints();
    }
  }
}

/**
* Прокси для ячейки с миной
*/
public class MineProxy extends Cell {
  private Mine proxy;

  public MineProxy(int left, int top) {
    super(left, top);
    
    this.proxy = null;
  }
  
  /**
   * Ленивая инициализация ячейки с миной
   */
  @Override
  public void open() {
    if (proxy == null) {
      proxy = new Mine(left, top);
    }
    
    proxy.open();
  }

  @Override
  public int getLeft() {
    if (proxy == null) {
      return left;
    } else {
      return proxy.getLeft();
    }
  
  }
  
  @Override
  public int getTop() {
    if (proxy == null) {
      return top;
    } else {
      return proxy.getTop();
    }
  }

  @Override
  public int getStatus() {
    if (proxy == null) {
      return status;
    } else {
      return proxy.getStatus();
    }
  }

  @Override
  public int getPoints() {
    if (proxy == null) {
      return 100;
    } else {
      return proxy.getPoints();
    }
  }
}

/**
* Использование
*/
public class Main {
  public static void main(String[] args) {
    Cell cells[][] = new Cell[10][10];
    
    for (int i=0; i<10; i++) {
      for (int j=0; j<10; j++) {
        
        if (i+j % 2 == 0) {
          cells[i][j] = new MineProxy(i, j);
        } else {
          cells[i][j] = new EmptyProxy(i, j);
        }
      }
    }
    
    for (int i=0; i<10; i++) {
      for (int j=0; j<10; j++) {
        cells[i][j].open();
      }
    }
  }
}
```
